#ifndef AIKIDO_CONSTRAINT_UNIFORM_RNCONSTANTSAMPLER_HPP_
#define AIKIDO_CONSTRAINT_UNIFORM_RNCONSTANTSAMPLER_HPP_

#include "aikido/constraint/Sampleable.hpp"
#include "aikido/statespace/Rn.hpp"

namespace aikido {
namespace constraint {
namespace uniform {

/// ConstantSampler for RealVectorStates.
/// Stub sampler for WeldJoint or any fixed constant state space.
template <int N>
class RConstantSampler : public constraint::Sampleable
{
public:
  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
  using VectorNd = Eigen::Matrix<double, N, 1>;

  /// Constructor.
  /// \param _space Space in which this constraint operates.
  /// \param _value Value to return when sampled.
  RConstantSampler(
      std::shared_ptr<statespace::R<N>> _space, const VectorNd& _value);

  // Documentation inherited.
  statespace::StateSpacePtr getStateSpace() const override;

  // Documentation inherited.
  std::unique_ptr<constraint::SampleGenerator> createSampleGenerator()
      const override;

  /// Returns constant value to be generated by this sampler.
  const VectorNd& getConstantValue() const;

private:
  std::shared_ptr<statespace::R<N>> mSpace;
  VectorNd mValue;
};

using R0ConstantSampler = RConstantSampler<0>;
using R1ConstantSampler = RConstantSampler<1>;
using R2ConstantSampler = RConstantSampler<2>;
using R3ConstantSampler = RConstantSampler<3>;
using R6ConstantSampler = RConstantSampler<6>;
using RnConstantSampler = RConstantSampler<Eigen::Dynamic>;

} // namespace uniform
} // namespace constraint
} // namespace aikido

#include "aikido/constraint/uniform/detail/RnConstantSampler-impl.hpp"

#endif // AIKIDO_CONSTRAINT_UNIFORM_RNCONSTANTSAMPLER_HPP_
